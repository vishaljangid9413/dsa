#include <iostream>
using namespace std;

/*
Problem Name: Construct Target Array With Multiple Sums
Problem Link: https://leetcode.com/problems/construct-target-array-with-multiple-sums/description/

Problem Statement:
Given an array `target` of integers, determine if it is possible to construct this array starting from an array of the same size filled with 1s. 
The construction process is defined as repeatedly taking the sum of all elements of the array and replacing one element with that sum. 
Return `true` if it is possible to reach the target array; otherwise, return `false`.

Example:
Input: target = [9,3,5]
Output: true
Explanation:
Start with [1,1,1] -> sum=3, replace largest element -> [3,1,1] -> sum=5, replace largest -> [3,5,1] -> sum=9, replace largest -> [9,5,1] -> rearrange -> [9,3,5]

Time Complexity:
- Each operation reduces the largest element. Using a max heap ensures that we always pick the largest element in O(log n) time.
- In the worst case, the loop may iterate up to log(max(target)) times for each element, so overall complexity is approximately O(n * log(max_val) * log n), where max_val is the largest element in `target`.

Space Complexity:
- We use a max heap to store elements: O(n) space.
- Other auxiliary variables use O(1) space.

Step-by-Step Approach:
1. **Reverse Thinking:** Instead of simulating the construction from [1,1,1,...], work backwards from `target` to see if it can be reduced to all 1s.
2. **Use a Max Heap:** Always pick the largest element in the array because it is the one that could have been generated by adding the sum of other elements.
3. **Calculate Remaining Sum:** Subtract the largest element from the total sum to get the sum of the rest of the elements.
4. **Validation Check:** 
   - If `remaining_sum <= 0` or `remaining_sum >= max_element`, itâ€™s impossible to have generated this number, so return false.
5. **Replace Largest Element:** Compute `max_element % remaining_sum` to simulate undoing the last sum operation.
   - If the result is 0 and `remaining_sum != 1`, return false.
   - Otherwise, update the heap and total sum with the replaced value.
6. **Repeat Until All Ones:** Continue until the largest element becomes 1. If the process succeeds without breaking the rules, return true.

Diagram to Visualize the Process:
Suppose `target = [9,3,5]`
*/


int main(){
    vector<int> target = {9,3,5};

    // define a max heap 
    int total_sum = 0;
    priority_queue<int>p;
    for(int i=0;i<target.size();i++){
        p.push(target[i]);
        total_sum += target[i];
    }
    bool ans = true;

    while(p.top() != 1){
        int max_element = p.top(); p.pop();
        int remaining_sum = total_sum - max_element;

        // verify the condtiion that remaining sum will not be less than or equals to 0 and greater than or equals to max element 

        // why, because technically we are getting remainins sum when we are removing max element from sum, so it should be positive 
        // if its not then it means the sum is lower than or equals to max_element and its not possible 
        // and if its greater than max_element than its also breaking the previous step that generate the next steps
        // because at the end we going reverse by decreasing the max element 
        if(remaining_sum <= 0 || remaining_sum >= max_element){
            break;
            ans = false;
        } 

        int replaced_value = max_element % remaining_sum;
        // if replaced value is 0 that will end your calculation
        if(replaced_value == 0){
            // if its because of remaining sum and if its not 1 then there is no ans possible
            // and it can't able to reach at possition where array consists all 1,1 elments
            if(remaining_sum != 1){
                ans = false;
            }
            break;;
        }

        total_sum = replaced_value + remaining_sum;

        p.push(replaced_value);
    }
    cout<<ans;
}


